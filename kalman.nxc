long cent_to_rot(float cent) {
     float perimetro_roda = 13.7;
     float rotations = (cent*360.0)/perimetro_roda;
     return rotations;
}

task main() {
     SetSensorLowspeed(IN_1);

     float sonar_variance = 1.2222222222224;
     float odom_variance = 0.022722222223335;
     
     float Pk[2];
     Pk[0] = sonar_variance;
     Pk[1] = odom_variance;
     float R[2];
     R[0] = sonar_variance;
     R[1] = odom_variance;
     float Gk[2];
     Gk[0] = sonar_variance;
     Gk[1] = odom_variance;
     
     float xi_odom = 0.0; // Posição inicial
     float xi_sonar= 0.0; // Posição inicialx
     float x_est = 0.0; // Movimentação estimada para próxima iteração
     float mov = 0.0;  // Movimentação total estimada
     float rot = 0.0;  // Rotações para proxima iteração
     
     //Posicao inicial é igual a estimada pelo sonar.
     xi_sonar = SensorUS(IN_1);
     xi_odom = xi_sonar;

     
     //estimativa de kalman
     float xk[2];
     xk[0] = xi_sonar;
     xk[1] = xi_odom;
     
     //estimativa de posicao sensorial
     float zk[2];
     zk[0] = xi_sonar;
     zk[1] = xi_odom;

     while (mov < 50.0) {
     
           //Cacula Pk + R
           float Pk_R[2];
           Pk_R[0] = Pk[0] + R[0];
           Pk_R[1] = Pk[1] + R[1];
           
           //Calcula inversa
           float Pk_R_aux[2];
           float det = (Pk_R[0]*Pk_R[1]);
           if (det == 0) {
              det = 1;
           }
           float termo = 1.0/det;

           Pk_R_aux[0] = termo*Pk_R[1];
           Pk_R_aux[1] = termo*Pk_R[0];
           
           //Calculando o ganho
           Gk[0] = Pk[0]*Pk_R_aux[0];
           Gk[1] = Pk[1]*Pk_R_aux[1];

           //Manda andar 5 centimetro
           rot = cent_to_rot(5);
           RotateMotor(OUT_AB, 75, rot);
           
           //Calcula estimativa de posicao sensorial
           xk[0] -= 5;
           xk[1] -= 5;

           //Calcula posicao "real"
           zk[0] = SensorUS(IN_1);
           zk[1] = xk[1]; //todo gerar random na volta de 5


           //Xk + Gk*(Zk - Xk)
           //termo_1 = Zk - Xk
           float termo_1[2];
           termo_1[0] = zk[0] - xk[0];
           termo_1[1] = zk[1] - xk[1];


           //termo_2 = Gk*termo_1
           float termo_2[2];
           termo_2[0] = Gk[0] * termo_1[0];
           termo_2[1] = Gk[1] * termo_1[1];

           //Xk = Xk + termo_2
           xk[0] = xk[0] + termo_2[0];
           xk[1] = xk[1] + termo_2[1];
           TextOut(20, LCD_LINE1, NumToStr(xk[0]));
           TextOut(20, LCD_LINE2, NumToStr(xk[1]));

           
           //Pondera Xk
           mov = -1*((xk[0]*0.5 + xk[1]*0.5)-xi_sonar);
           
           //Calcula o Pk
           float Pk_aux[2];
           Pk_aux[0] = Pk[0];
           Pk_aux[1] = Pk[1];

           Pk[0] = (1-Gk[0])*Pk_aux[0];
           Pk[1] = (1-Gk[1])*Pk_aux[1];
           
           
           TextOut(20, LCD_LINE4, NumToStr(Gk[0]));
           TextOut(20, LCD_LINE5, NumToStr(Gk[1]));
           TextOut(20, LCD_LINE3, NumToStr(mov));
           Wait(1000);
     }
     
     
}

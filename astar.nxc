#define INF 9999

long djikstra(int n, int v, int cost, int dist) {
     //todo
}

long cent_to_rot(float cent) {
     float perimetro_roda = 13.7;
     float rotations = (cent*360.0)/perimetro_roda;
     return rotations;
}

void gira(int ori) {
     if (ori == 0) {
        //gira pra direita
     }
     else if (ori == 1) {
        //gira pra esquerda
     }
     
}

void gira_sonar(int ori) {
     if (ori == 0) {
     
     }
     else if (ori == 1) {
     
     }
}

//orientacao atual e orientacao do que quer olhar
void gira_olha(int ori, int ori_olhar) {
     if (abs(ori - ori_olhar) == 2) {
        gira(0);
        gira_sonar(0);
     }
     else {
        if(ori == 0 || ori_olhar == 0) {
           if (ori == 0 && ori_olhar == 3) {
              gira_sonar(0);
           }
           else if (ori == 3 && ori_olhar == 0) {
              gira_sonar(1);
           }
           else if (ori == 1 && ori_olhar == 0) {
              gira_sonar(0);
           }
           else if (ori == 0 && ori_olhar == 1) {
              gira_sonar(1);
           }
        }
        else {
           if (ori > ori_olhar) {
              gira_sonar(1);
           }
           else {
              gira_sonar(0);
           }
        }
     }

}

int dist_manhattan(pos_x, pos_y, goal_x, goal_y) {
    int dist = abs(goal_x - pos_x) + abs(goal_y - pos_y);
}

task main() {
     //-2 é o objetivo, -1 é obstáculo
     int tam_campo = 10; //cent em cada campo do espaco
     int ori = 0;
     int pos_x = 13;
     int pos_y = 13;
     int espaco_x = 25;
     int espaco_y = 25;
     //heuristica: distancia pro goal
     SetSensorLowspeed(IN_1);

     int espaco[25][25][2] = {0};
     int obs = SensorUS(IN_1);
     //encontra a posicao no espaco do objetivo
     obs = obs/tam_campo;
     espaco[pos_x+obs][pos_y] = 0;

     int goal_x = pos_x + initial;
     int goal_y = pos_y;
     
     //calcula distancia de manhattan de todos os nodos para o goal
     int i,j;
     for (i=0; i<espaco_x; i++) {
        for (j=0; j<espaco_y; j++) {
            espaco[i][j][1] = dist_manhattan(i, j, goal_x, goal_y);
        }
     }

     //coloca os obstaculos
     Wait(5000);
     
     //loop pra encontra o goal
     while ((goal_x != pos_x) && (goal_y != pos_y)) {
     
           //encontra obstaculo
           obs = SensorUS(IN_1);
           if (obs < 255) {
              obs = obs/tam_campo;
              if (ori == 0) {
                 espaco[pos_x+obs][pos_y][0] = -1;
              }
              else if (ori == 1) {
                 espaco[pos_x][pos_y+obs][0] = -1;
              }
              else if (ori == 2) {
                 espaco[pos_x-obs][pos_y][0] = -1;
              }
              else if (ori == 3) {
                 espaco[pos_x][pos_y-obs][0] = -1;
              }
           }
           
           //expande para os 4 adjacentes
           if (espaco[pos_x+1][pos_y][0] != 0) {
              if (espaco[pos_x+1][pos_y][0] > tam_campo + espaco[pos_x][pos_y][0]) {
                 espaco[pos_x+1][pos_y][0] = tam_campo + espaco[pos_x][pos_y][0];
              }
           }
           else {
              //verifica se existe obstaculo (gira e olha)
              gira_olha(ori, 0);

           }
           if (espaco[pos_x][pos_y+obs][0] != 0) {
              if (espaco[pos_x][pos_y+1][0] > tam_campo + espaco[pos_x][pos_y][0]) {
                 espaco[pos_x][pos_y+1][0] = tam_campo + espaco[pos_x][pos_y][0];
              }
           }
           else {
                //verifica se existe obstaculo (gira e olha)
                gira_olha(ori, 1);

           }
           if (espaco[pos_x-1][pos_y][0] != 0) {
              if (espaco[pos_x-1][pos_y][0] > tam_campo + espaco[pos_x][pos_y][0]) {
                 espaco[pos_x-1][pos_y][0] = tam_campo + espaco[pos_x][pos_y][0];
              }
           }
           else {
                gira_olha(ori, 2);

           }
           if (espaco[pos_x][pos_y-1][0]) != 0 {
              if (espaco[pos_x][pos_y-1][0] > tam_campo + espaco[pos_x][pos_y][0]) {
                 espaco[pos_x][pos_y-1][0] = tam_campo + espaco[pos_x][pos_y][0];

              }
           }
           else {
                gira_olha(ori, 3);
           
           }
           
           //encontra proximo nodo a visitar
           int menor_x = INF;
           int menor_y = INF;
           int menor = INF;
           
           for (i=0; i<espaco_x; i++) {
               for (j=0; j<espaco_y; j++) {
                   //encontra o menor nodo
                   if (espaco[i][j][0] + espaco[i][j][1] < menor) {
                      menor_x = i;
                      menor_y = j;
                      menor = espaco[i][j][0] + espaco[i][j][1];
                   }
               }
           }
           
           //calcula djikstra entre o menor e o atual
           
           //visita nodo
           
           //adicionar o nodo na matriz de adjacencia

           
     }
     

}
